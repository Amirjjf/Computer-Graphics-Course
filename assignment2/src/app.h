#pragma once

// Include libraries
#include "glad/gl_core_33.h"                // OpenGL
#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>             // Window manager
#include <imgui.h>                  // GUI Library
#include <imgui_impl_glfw.h>
#include "imgui_impl_opengl3.h"

#include <Eigen/Dense>              // Linear algebra
#include <Eigen/Geometry>

#include <nlohmann/json.hpp>        // JSON library

#include <string>
#include <vector>
#include <memory>

#include "app_base.h"

using std::string, std::vector, std::unique_ptr;
using Eigen::Vector3f, Eigen::Matrix3f, Eigen::Vector4f, Eigen::Matrix4f, Eigen::Vector3i;

enum class DrawMode
{
    Curves,
    Subdivision_R3,
    Subdivision_R3_R4,
    Subdivision
};

#include "Timer.h"      // From shared sources -->
#include "ShaderProgram.h"
#include "Utils.h"
#include "eigen_json_serializers.h"
#include "camera.h"     // From this assignment-->
#include "camera_json_serializer.h"
#include "curve.h"
#include "surf.h"
#include "subdiv.h"

//------------------------------------------------------------------------

// State structure with JSON serialization support; see Instructions.
// Note: if you add fields, be sure to do a full rebuild to keep everything consistent!
#define STATE_FIELDS(F)                                             \
    F(string, filename, "")                                         \
    F(DrawMode, mode, DrawMode::Curves)                             \
    F(uint32_t, spline_tessellation, 8)                             \
    F(bool, show_surface, false)                                    \
    F(uint32_t, subdivision, 0)                                     \
    F(bool, wireframe, false)                                       \
    F(bool, crude_boundaries, false)                                \
    F(Camera, camera, )                                             \
    F(bool, draw_frames, false)

// This includes the macro magic that turns the above STATE_FIELDS sequence into struct AppState { ... }
// that has the appropriate members and autogenerated JSON serialization code.
#include "app_state.h"

//------------------------------------------------------------------------

// Structure for holding vertex data.
// PNC stands for Position, Normal, Color
struct VertexPNC
{
    Vector3f position   = Vector3f::Zero();
    Vector3f normal     = Vector3f::Zero();
    Vector3f color      = Vector3f::Zero();
};

//------------------------------------------------------------------------

class App : AppBase
{
private:

public:
                        App(void);
                        ~App(void);

    void				run(const filesystem::path savePNGAndTerminate);

    AppState m_state;

private:
                        App(const App&) = delete; // forbidden
                        App& operator=(const App&) = delete; // forbidden


    void render(const AppState& state, int window_width, int window_height, vector<string>& vecStatusMessages) const;

    // cache variables used in render()
    struct {

        // settings
        bool        debug_subdivision = false;
        DrawMode    mode = DrawMode::Curves;
        string      filename = "";
        uint32_t    subdivision = 0;
        int         tessellation_steps = 8;
        bool        crude_boundaries = false;

        // spline and mesh data
        vector<SplineCurve>	                        spline_curves;
        vector<vector<CurvePoint>>                  tessellated_curves;
        vector<ParsedSurface>                       surfaces;
        MeshWithConnectivity                        surface_mesh;
        vector<unique_ptr<MeshWithConnectivity>>    subdivided_meshes;

    } mutable m_render_cache;

    void update_render_cache(const AppState& state) const;

    void arcballRotation(int end_x, int end_y);
    void setupViewportAndProjection(int w, int h);
    void drawScene      (void);
    void initRendering  (void);
    // void loadSWP        (const string& filename) const;
    void writeObjects   (const string& filename);
    void loadOBJ        (const string& filename) const;
    void renderCurves   (bool draw_frames) const;
    void screenshot     (const string& name);
    void handleLoading();


    void tessellateCurves(int tessellation_steps) const;
    void generateSurfaces(int tessellation_steps) const;

    enum VertexShaderAttributeLocations {
        ATTRIB_POSITION = 0,
        ATTRIB_NORMAL = 1,
        ATTRIB_COLOR = 2
    };

    struct glGeneratedIndices
    {
        GLuint shader_program;
        GLuint vao;
        GLuint vertex_buffer;
        GLuint index_buffer;
    GLuint world_to_view_uniform, view_to_clip_uniform, shading_toggle_uniform, camera_world_position_uniform;
    GLuint ambient_strength_uniform, specular_strength_uniform, shininess_uniform;
    GLuint rim_strength_uniform, rim_color_uniform, specular_color_uniform;
    };

    glGeneratedIndices m_gl;

    ShaderProgram*                              m_subdivision_shader = nullptr;

    void                addSubdivisionLevel(DrawMode mode, bool crude_boundaries) const;

    void                uploadGeometryToGPU(const MeshWithConnectivity& m) const;
    void                renderMesh(const MeshWithConnectivity& m, const Camera& cam, bool include_wireframe, int highlight_triangle, int highlight_vertex) const;
    std::tuple<int,int> pickTriangle(const MeshWithConnectivity& m, const Camera& cam, int window_width, int window_height, float mousex, float mousey) const;


    void				handleKeypress(GLFWwindow* window, int key, int scancode, int action, int mods);
    void				handleMouseButton(GLFWwindow* window, int button, int action, int mods);
    void				handleMouseMovement(GLFWwindow* window, double xpos, double ypos);
    void				handleDrop(GLFWwindow* window, int count, const char** paths);

	// Vector for storing indices for debugging
	mutable vector<int> m_debug_indices;
    bool                m_toggle_onering = false;
    bool                m_debug_subdivision = false;
        ;

    // -------- Curve editor state --------
    mutable bool        m_curve_edit_mode = false;   // UI toggle
    mutable int         m_edit_curve_idx = -1;       // active curve
    mutable int         m_edit_point_idx = -1;       // selected control point
    mutable bool        m_dragging_point = false;    // dragging flag
    mutable float       m_pick_radius_pixels = 16.0f;// screen-space pick radius
    mutable bool        m_surfaces_dirty = false;     // regenerate surfaces lazily

    // Helpers for curve editing
    Vector3f            screenToRayOrigin(const Camera& cam) const;
    Vector3f            screenToRayDir(const Camera& cam, int fbWidth, int fbHeight, double mousex, double mousey) const;
    bool                intersectPlaneZ0(const Vector3f& o, const Vector3f& d, Vector3f& hit) const;
    int                 pickControlPointScreen(int curveIdx, int fbWidth, int fbHeight, double mousex, double mousey) const;
    void                retriangulateAfterEdit() const;
};
